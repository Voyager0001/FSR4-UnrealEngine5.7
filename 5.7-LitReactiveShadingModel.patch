diff --git a/Engine/Plugins/2D/Paper2D/Source/Paper2DEditor/Private/SpriteEditor/SpriteDetailsCustomization.cpp b/Engine/Plugins/2D/Paper2D/Source/Paper2DEditor/Private/SpriteEditor/SpriteDetailsCustomization.cpp
index fa91bb3a56..1a89c8bcc3 100644
--- a/Engine/Plugins/2D/Paper2D/Source/Paper2DEditor/Private/SpriteEditor/SpriteDetailsCustomization.cpp
+++ b/Engine/Plugins/2D/Paper2D/Source/Paper2DEditor/Private/SpriteEditor/SpriteDetailsCustomization.cpp
@@ -503,7 +503,7 @@ FText FSpriteDetailsCustomization::GetRenderingHeaderContentText(TWeakObjectPtr<
 			{
 				MaterialType = LOCTEXT("Unlit", "Unlit");
 			}
-			else if (ShadingModels.HasOnlyShadingModel(MSM_DefaultLit))
+			else if (ShadingModels.HasOnlyShadingModel(MSM_DefaultLit) || ShadingModels.HasOnlyShadingModel(MSM_LitReactive))
 			{
 				MaterialType = LOCTEXT("Lit", "Lit");
 			}
diff --git a/Engine/Shaders/Private/BasePassCommon.ush b/Engine/Shaders/Private/BasePassCommon.ush
index f94b43afd7..0ba459fbbd 100644
--- a/Engine/Shaders/Private/BasePassCommon.ush
+++ b/Engine/Shaders/Private/BasePassCommon.ush
@@ -41,7 +41,7 @@
 #define USES_GBUFFER						(FEATURE_LEVEL >= FEATURE_LEVEL_SM4 && (MATERIALBLENDING_SOLID || MATERIALBLENDING_MASKED) && !FORWARD_SHADING)
 
 // Only some shader models actually need custom data.
-#define WRITES_CUSTOMDATA_TO_GBUFFER		(USES_GBUFFER && (MATERIAL_SHADINGMODEL_SUBSURFACE || MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN || MATERIAL_SHADINGMODEL_SUBSURFACE_PROFILE || MATERIAL_SHADINGMODEL_CLEAR_COAT || MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE || MATERIAL_SHADINGMODEL_HAIR || MATERIAL_SHADINGMODEL_CLOTH || MATERIAL_SHADINGMODEL_EYE))
+#define WRITES_CUSTOMDATA_TO_GBUFFER		(USES_GBUFFER && (MATERIAL_SHADINGMODEL_SUBSURFACE || MATERIAL_SHADINGMODEL_PREINTEGRATED_SKIN || MATERIAL_SHADINGMODEL_SUBSURFACE_PROFILE || MATERIAL_SHADINGMODEL_CLEAR_COAT || MATERIAL_SHADINGMODEL_TWOSIDED_FOLIAGE || MATERIAL_SHADINGMODEL_HAIR || MATERIAL_SHADINGMODEL_CLOTH || MATERIAL_SHADINGMODEL_EYE || MATERIAL_SHADINGMODEL_LIT_REACTIVE))
 
 // Based on GetPrecomputedShadowMasks()
 // Note: WRITES_PRECSHADOWFACTOR_TO_GBUFFER is currently disabled because we use the precomputed shadow factor GBuffer outside of STATICLIGHTING_TEXTUREMASK to store UseSingleSampleShadowFromStationaryLights
diff --git a/Engine/Shaders/Private/BasePassPixelShader.usf b/Engine/Shaders/Private/BasePassPixelShader.usf
index 6e65791719..bee896f32f 100644
--- a/Engine/Shaders/Private/BasePassPixelShader.usf
+++ b/Engine/Shaders/Private/BasePassPixelShader.usf
@@ -1545,7 +1545,7 @@ void FPixelShaderInOut_MainPS(
 
 	// Volume lighting for lit translucency
 #if (MATERIAL_SHADINGMODEL_DEFAULT_LIT || MATERIAL_SHADINGMODEL_SUBSURFACE) && (MATERIALBLENDING_TRANSLUCENT || MATERIALBLENDING_ADDITIVE) && !FORWARD_SHADING && !TRANSLUCENCY_LIGHTING_SURFACE_FORWARDSHADING
-	if (GBuffer.ShadingModelID == SHADINGMODELID_DEFAULT_LIT || GBuffer.ShadingModelID == SHADINGMODELID_SUBSURFACE)
+	if (GBuffer.ShadingModelID == SHADINGMODELID_DEFAULT_LIT || GBuffer.ShadingModelID == SHADINGMODELID_SUBSURFACE || GBuffer.ShadingModelID == SHADINGMODELID_LIT_REACTIVE)
 	{
 		float3 TLVDiffuseLighting;
 		float3 TLVSpecularLighting;
diff --git a/Engine/Shaders/Private/ClusteredDeferredShadingPixelShader.usf b/Engine/Shaders/Private/ClusteredDeferredShadingPixelShader.usf
index fa390f21ce..cdf2fef53d 100644
--- a/Engine/Shaders/Private/ClusteredDeferredShadingPixelShader.usf
+++ b/Engine/Shaders/Private/ClusteredDeferredShadingPixelShader.usf
@@ -420,6 +420,7 @@ void ClusteredShadingPixelShader(
 	GET_LIGHT_GRID_LOCAL_LIGHTING_SINGLE_SM(SHADINGMODELID_CLOTH,				PixelShadingModelID, CompositedLighting, ScreenUV, CulledLightGridHeader, Dither);
 	GET_LIGHT_GRID_LOCAL_LIGHTING_SINGLE_SM(SHADINGMODELID_EYE,					PixelShadingModelID, CompositedLighting, ScreenUV, CulledLightGridHeader, Dither);
 	GET_LIGHT_GRID_LOCAL_LIGHTING_SINGLE_SM(SHADINGMODELID_SINGLELAYERWATER,	PixelShadingModelID, CompositedLighting, ScreenUV, CulledLightGridHeader, Dither);
+	GET_LIGHT_GRID_LOCAL_LIGHTING_SINGLE_SM(SHADINGMODELID_LIT_REACTIVE,		PixelShadingModelID, CompositedLighting, ScreenUV, CulledLightGridHeader, Dither);
 	// SHADINGMODELID_THIN_TRANSLUCENT - skipping because it can not be opaque
 #else // !USE_PASS_PER_SHADING_MODEL
 	CompositedLighting += GetLightGridLocalLighting(GetScreenSpaceData(ScreenUV), CulledLightGridHeader, TranslatedWorldPosition, CameraVector, ScreenUV, SceneDepth, 0, Dither);
diff --git a/Engine/Shaders/Private/DeferredShadingCommon.ush b/Engine/Shaders/Private/DeferredShadingCommon.ush
index d9ef2b1074..27b1512dcd 100644
--- a/Engine/Shaders/Private/DeferredShadingCommon.ush
+++ b/Engine/Shaders/Private/DeferredShadingCommon.ush
@@ -323,7 +323,8 @@ bool HasCustomGBufferData(int ShadingModelID)
 		|| ShadingModelID == SHADINGMODELID_TWOSIDED_FOLIAGE
 		|| ShadingModelID == SHADINGMODELID_HAIR
 		|| ShadingModelID == SHADINGMODELID_CLOTH
-		|| ShadingModelID == SHADINGMODELID_EYE;
+		|| ShadingModelID == SHADINGMODELID_EYE
+		|| ShadingModelID == SHADINGMODELID_LIT_REACTIVE;
 }
 
 bool HasAnisotropy(int SelectiveOutputMask)
diff --git a/Engine/Shaders/Private/Definitions.usf b/Engine/Shaders/Private/Definitions.usf
index 1d3afe292b..9bddd3424b 100644
--- a/Engine/Shaders/Private/Definitions.usf
+++ b/Engine/Shaders/Private/Definitions.usf
@@ -105,6 +105,10 @@
 #define MATERIAL_SHADINGMODEL_DEFAULT_LIT				0
 #endif
 
+#ifndef MATERIAL_SHADINGMODEL_LIT_REACTIVE
+#define MATERIAL_SHADINGMODEL_LIT_REACTIVE				0
+#endif
+
 #ifndef MATERIAL_SHADINGMODEL_SUBSURFACE
 #define MATERIAL_SHADINGMODEL_SUBSURFACE				0
 #endif
diff --git a/Engine/Shaders/Private/PathTracing/Material/PathTracingMaterialSampling.ush b/Engine/Shaders/Private/PathTracing/Material/PathTracingMaterialSampling.ush
index e3edd6ae82..70372277f5 100644
--- a/Engine/Shaders/Private/PathTracing/Material/PathTracingMaterialSampling.ush
+++ b/Engine/Shaders/Private/PathTracing/Material/PathTracingMaterialSampling.ush
@@ -87,6 +87,7 @@ float3 EstimateMaterialAlbedo(FPathTracingPayload Payload)
 			Albedo = Payload.DiffuseColor + Payload.SpecularColor + Payload.SubsurfaceColor;
 			break;
 		case SHADINGMODELID_DEFAULT_LIT:
+		case SHADINGMODELID_LIT_REACTIVE:
 			Albedo = Payload.DiffuseColor + Payload.SpecularColor;
 			break;
 		case SHADINGMODELID_CLEAR_COAT:
@@ -225,6 +226,7 @@ void AccumulateAlbedoNormal(inout FPathTracingPayload Payload, float3 PathThroug
 		Normal += BrdfWeight * NormThroughput * Payload.WorldNormal;
 		break;
 	case SHADINGMODELID_DEFAULT_LIT:
+	case SHADINGMODELID_LIT_REACTIVE:
 	case SHADINGMODELID_CLEAR_COAT: // TODO: can we be more precise with clearcoat?
 		Albedo += BrdfWeight * PathThroughput * (Payload.DiffuseColor + RoughnessWeight * Payload.SpecularColor);
 		Normal += BrdfWeight * NormThroughput * Payload.WorldNormal;
@@ -591,6 +593,7 @@ FMaterialSample SampleMaterial(
 			return SubstrateClearCoat_SampleMaterial(V_World, Payload, RandSample);
 #else
 		case SHADINGMODELID_DEFAULT_LIT:
+		case SHADINGMODELID_LIT_REACTIVE:
 		case SHADINGMODELID_SUBSURFACE:
 		case SHADINGMODELID_PREINTEGRATED_SKIN:
 			return DefaultLit_SampleMaterial(V_World, Payload, RandSample);
@@ -648,6 +651,7 @@ FMaterialEval EvalMaterial(
 			return SubstrateClearCoat_EvalMaterial(V_World, L_World, Payload, DiffuseSpecularScale);
 #else
 		case SHADINGMODELID_DEFAULT_LIT:
+		case SHADINGMODELID_LIT_REACTIVE:
 		case SHADINGMODELID_SUBSURFACE:
 		case SHADINGMODELID_PREINTEGRATED_SKIN:
 			return DefaultLit_EvalMaterial(V_World, L_World, Payload, DiffuseSpecularScale);
diff --git a/Engine/Shaders/Private/PathTracing/PathTracingMaterialHitShader.usf b/Engine/Shaders/Private/PathTracing/PathTracingMaterialHitShader.usf
index 3fa33a5763..89764deb5b 100644
--- a/Engine/Shaders/Private/PathTracing/PathTracingMaterialHitShader.usf
+++ b/Engine/Shaders/Private/PathTracing/PathTracingMaterialHitShader.usf
@@ -1217,8 +1217,8 @@ RAY_TRACING_ENTRY_CLOSEST_HIT(PathTracingMaterialCHS,
 	else
 #endif // MATERIAL_SHADINGMODEL_EYE
 
-#if MATERIAL_SHADINGMODEL_DEFAULT_LIT
-	if (Payload.ShadingModelID == SHADINGMODELID_DEFAULT_LIT)
+#if MATERIAL_SHADINGMODEL_DEFAULT_LIT || MATERIAL_SHADINGMODEL_LIT_REACTIVE
+	if (Payload.ShadingModelID == SHADINGMODELID_DEFAULT_LIT || Payload.ShadingModelID == SHADINGMODELID_LIT_REACTIVE)
 	{
 		#if USE_LEGACY_CODEPATH_FOR_SUBSTRATE
 		Payload.ShadingModelID = SHADINGMODELID_SUBSTRATE;
diff --git a/Engine/Shaders/Private/RayTracing/RayTracingMaterialHitShaders.usf b/Engine/Shaders/Private/RayTracing/RayTracingMaterialHitShaders.usf
index dd8b258254..ded773de6d 100644
--- a/Engine/Shaders/Private/RayTracing/RayTracingMaterialHitShaders.usf
+++ b/Engine/Shaders/Private/RayTracing/RayTracingMaterialHitShaders.usf
@@ -571,6 +571,13 @@ void GetMaterialPayload(
 	}
 #endif
 
+#if MATERIAL_SHADINGMODEL_LIT_REACTIVE
+	if (Payload.ShadingModelID == SHADINGMODELID_LIT_REACTIVE)
+	{
+		Payload.CustomData.x = GetMaterialCustomData0(PixelMaterialInputs);
+	}
+#endif
+	
 #if MATERIAL_USES_ANISOTROPY
 	Payload.WorldTangent = WorldTangent;
 	Payload.Anisotropy = Anisotropy;
diff --git a/Engine/Shaders/Private/ShadingCommon.ush b/Engine/Shaders/Private/ShadingCommon.ush
index 5b0f42facc..4f3d2d79f2 100644
--- a/Engine/Shaders/Private/ShadingCommon.ush
+++ b/Engine/Shaders/Private/ShadingCommon.ush
@@ -30,7 +30,8 @@
 #define SHADINGMODELID_SINGLELAYERWATER		10
 #define SHADINGMODELID_THIN_TRANSLUCENT		11
 #define SHADINGMODELID_SUBSTRATE			12		// Temporary while we convert everything to Substrate
-#define SHADINGMODELID_NUM					13
+#define SHADINGMODELID_LIT_REACTIVE         13
+#define SHADINGMODELID_NUM					14
 #define SHADINGMODELID_MASK					0xF		// 4 bits reserved for ShadingModelID			
 
 // The flags are defined so that 0 value has no effect!
@@ -63,6 +64,7 @@ float3 GetShadingModelColor(uint ShadingModelID)
 	else if (ShadingModelID == SHADINGMODELID_SINGLELAYERWATER) return float3(0.5f, 0.5f, 1.0f);
 	else if (ShadingModelID == SHADINGMODELID_THIN_TRANSLUCENT) return float3(1.0f, 0.8f, 0.3f);
 	else if (ShadingModelID == SHADINGMODELID_SUBSTRATE) return float3(1.0f, 1.0f, 0.0f);
+	else if (ShadingModelID == SHADINGMODELID_LIT_REACTIVE) return float3(1.0f, 0.8f, 0.5f);
 	else return float3(1.0f, 1.0f, 1.0f); // White
 #else
 	switch(ShadingModelID)
@@ -80,6 +82,7 @@ float3 GetShadingModelColor(uint ShadingModelID)
 		case SHADINGMODELID_SINGLELAYERWATER: return float3(0.5f, 0.5f, 1.0f);
 		case SHADINGMODELID_THIN_TRANSLUCENT: return float3(1.0f, 0.8f, 0.3f);
 		case SHADINGMODELID_SUBSTRATE: return float3(1.0f, 1.0f, 0.0f);
+		case SHADINGMODELID_LIT_REACTIVE: return float3(1.0f, 0.8f, 0.5f);
 		default: return float3(1.0f, 1.0f, 1.0f); // White
 	}
 #endif
diff --git a/Engine/Shaders/Private/ShadingModels.ush b/Engine/Shaders/Private/ShadingModels.ush
index 744989d891..a8bff6a54a 100644
--- a/Engine/Shaders/Private/ShadingModels.ush
+++ b/Engine/Shaders/Private/ShadingModels.ush
@@ -1068,6 +1068,7 @@ FDirectLighting IntegrateBxDF( FGBufferData GBuffer, half3 N, half3 V, FAreaLigh
 	switch( GBuffer.ShadingModelID )
 	{
 		case SHADINGMODELID_DEFAULT_LIT:
+		case SHADINGMODELID_LIT_REACTIVE:
 		case SHADINGMODELID_SINGLELAYERWATER:
 		case SHADINGMODELID_THIN_TRANSLUCENT:
 			return DefaultLitBxDF( GBuffer, N, V, AreaLight, Shadow );
diff --git a/Engine/Shaders/Private/ShadingModelsMaterial.ush b/Engine/Shaders/Private/ShadingModelsMaterial.ush
index 9f73d409d7..662fab7aac 100644
--- a/Engine/Shaders/Private/ShadingModelsMaterial.ush
+++ b/Engine/Shaders/Private/ShadingModelsMaterial.ush
@@ -44,6 +44,12 @@ void SetGBufferForShadingModel(
 	if (false)
 	{
 	}
+#if MATERIAL_SHADINGMODEL_LIT_REACTIVE
+   else if (ShadingModel == SHADINGMODELID_LIT_REACTIVE)
+   {
+       GBuffer.CustomData.x = GetMaterialCustomData0(PixelMaterialInputs);
+   }
+#endif
 #if MATERIAL_SHADINGMODEL_SUBSURFACE
 	else if (ShadingModel == SHADINGMODELID_SUBSURFACE)
 	{
diff --git a/Engine/Shaders/Private/ShadingModelsSampling.ush b/Engine/Shaders/Private/ShadingModelsSampling.ush
index c10b4778d3..1709a359c3 100644
--- a/Engine/Shaders/Private/ShadingModelsSampling.ush
+++ b/Engine/Shaders/Private/ShadingModelsSampling.ush
@@ -207,6 +207,7 @@ FBxDFSample SampleBxDF(const uint TermMask, FGBufferData GBuffer, float3 V, floa
 	switch( GBuffer.ShadingModelID )
 	{
 		case SHADINGMODELID_DEFAULT_LIT:
+		case SHADINGMODELID_LIT_REACTIVE:
 		case SHADINGMODELID_SINGLELAYERWATER:
 		case SHADINGMODELID_SUBSURFACE:
 		case SHADINGMODELID_SUBSURFACE_PROFILE:
@@ -228,6 +229,7 @@ bool SupportsSampleBxDF(uint ShadingModelID)
 	switch (ShadingModelID)
 	{
 	case SHADINGMODELID_DEFAULT_LIT:
+	case SHADINGMODELID_LIT_REACTIVE:
 	case SHADINGMODELID_SINGLELAYERWATER:
 	case SHADINGMODELID_SUBSURFACE:
 	case SHADINGMODELID_SUBSURFACE_PROFILE:
diff --git a/Engine/Source/Editor/PixelInspector/Private/PixelInspectorDetailsCustomization.cpp b/Engine/Source/Editor/PixelInspector/Private/PixelInspectorDetailsCustomization.cpp
index 54da163053..d9cfc54de7 100644
--- a/Engine/Source/Editor/PixelInspector/Private/PixelInspectorDetailsCustomization.cpp
+++ b/Engine/Source/Editor/PixelInspector/Private/PixelInspectorDetailsCustomization.cpp
@@ -164,6 +164,7 @@ void FPixelInspectorDetailsCustomization::CustomizeDetails(IDetailLayoutBuilder&
 		case MSM_SingleLayerWater:
 		case MSM_ThinTranslucent:
 		case MSM_Unlit:
+		case MSM_LitReactive:
 		{
 			DetailBuilder.HideProperty(SubSurfaceColorProp);
 			DetailBuilder.HideProperty(SubSurfaceProfileProp);
diff --git a/Engine/Source/Editor/PixelInspector/Private/PixelInspectorResult.cpp b/Engine/Source/Editor/PixelInspector/Private/PixelInspectorResult.cpp
index aa59d9e0ea..3774e82caa 100644
--- a/Engine/Source/Editor/PixelInspector/Private/PixelInspectorResult.cpp
+++ b/Engine/Source/Editor/PixelInspector/Private/PixelInspectorResult.cpp
@@ -267,6 +267,8 @@ namespace PixelInspector
 			return EMaterialShadingModel::MSM_ThinTranslucent;
 		case PIXEL_INSPECTOR_SHADINGMODELID_SUBSTRATE:
 			return EMaterialShadingModel::MSM_Strata;
+		case PIXEL_INSPECTOR_SHADINGMODELID_LIT_REACTIVE:
+			return EMaterialShadingModel::MSM_LitReactive;
 		};
 		return EMaterialShadingModel::MSM_DefaultLit;
 	}
@@ -361,6 +363,12 @@ namespace PixelInspector
 			IrisDistance = InCustomData.W;
 		}
 		break;
+		case EMaterialShadingModel::MSM_LitReactive:
+		{
+			SubSurfaceColor = FVector3f(0.0f);
+			Opacity = InCustomData.X;
+		}
+		break;
 		};
 	}
 };
diff --git a/Engine/Source/Editor/PixelInspector/Private/PixelInspectorResult.h b/Engine/Source/Editor/PixelInspector/Private/PixelInspectorResult.h
index 1ab7f6bf2c..b1bc058d11 100644
--- a/Engine/Source/Editor/PixelInspector/Private/PixelInspectorResult.h
+++ b/Engine/Source/Editor/PixelInspector/Private/PixelInspectorResult.h
@@ -25,6 +25,7 @@ class FFloat16Color;
 #define PIXEL_INSPECTOR_SHADINGMODELID_SINGLELAYERWATER 10
 #define PIXEL_INSPECTOR_SHADINGMODELID_THIN_TRANSLUCENT 11
 #define PIXEL_INSPECTOR_SHADINGMODELID_SUBSTRATE 12
+#define PIXEL_INSPECTOR_SHADINGMODELID_LIT_REACTIVE 13
 #define PIXEL_INSPECTOR_SHADINGMODELID_MASK 0xF
 
 namespace PixelInspector
diff --git a/Engine/Source/Editor/UnrealEd/Private/Lightmass/LightmassRender.cpp b/Engine/Source/Editor/UnrealEd/Private/Lightmass/LightmassRender.cpp
index ea46666cc5..d043d04efa 100644
--- a/Engine/Source/Editor/UnrealEd/Private/Lightmass/LightmassRender.cpp
+++ b/Engine/Source/Editor/UnrealEd/Private/Lightmass/LightmassRender.cpp
@@ -1141,7 +1141,8 @@ bool FLightmassMaterialRenderer::GenerateMaterialData(
 		!ShadingModels.HasShadingModel(MSM_Unlit) &&
 		!ShadingModels.HasShadingModel(MSM_Subsurface) &&
 		!ShadingModels.HasShadingModel(MSM_PreintegratedSkin) &&
-		!ShadingModels.HasShadingModel(MSM_SubsurfaceProfile))
+		!ShadingModels.HasShadingModel(MSM_SubsurfaceProfile) &&
+		!ShadingModels.HasShadingModel(MSM_LitReactive))
 	{
 		UE_LOG(LogLightmassRender, Warning, TEXT("LIGHTMASS: Material has an unsupported shading model: %d on %s"), 
 			(int32)ShadingModels.GetShadingModelField(),
diff --git a/Engine/Source/Runtime/Engine/Classes/Engine/EngineTypes.h b/Engine/Source/Runtime/Engine/Classes/Engine/EngineTypes.h
index 389a4430ce..30dc8e679c 100644
--- a/Engine/Source/Runtime/Engine/Classes/Engine/EngineTypes.h
+++ b/Engine/Source/Runtime/Engine/Classes/Engine/EngineTypes.h
@@ -716,6 +716,7 @@ enum EMaterialShadingModel : int
 	MSM_SingleLayerWater		UMETA(DisplayName="SingleLayerWater"),
 	MSM_ThinTranslucent			UMETA(DisplayName="Thin Translucent"),
 	MSM_Strata					UMETA(DisplayName="Substrate", Hidden),
+	MSM_LitReactive				UMETA(DisplayName = "Lit Reactive"),
 	/** Number of unique shading models. */
 	MSM_NUM						UMETA(Hidden),
 	/** Shading model will be determined by the Material Expression Graph,
diff --git a/Engine/Source/Runtime/Engine/Private/Materials/HLSLMaterialTranslator.cpp b/Engine/Source/Runtime/Engine/Private/Materials/HLSLMaterialTranslator.cpp
index 45a964affd..6b85f96b1b 100644
--- a/Engine/Source/Runtime/Engine/Private/Materials/HLSLMaterialTranslator.cpp
+++ b/Engine/Source/Runtime/Engine/Private/Materials/HLSLMaterialTranslator.cpp
@@ -2948,6 +2948,11 @@ void FHLSLMaterialTranslator::GetMaterialEnvironment(EShaderPlatform InPlatform,
 			OutEnvironment.SetDefine(TEXT("MATERIAL_SHADINGMODEL_DEFAULT_LIT"), TEXT("1"));
 		}
 
+		if (EnvironmentDefines->HasShadingModel(MSM_LitReactive))
+		{
+			OutEnvironment.SetDefine(TEXT("MATERIAL_SHADINGMODEL_LIT_REACTIVE"), TEXT("1"));
+		}
+
 		if (EnvironmentDefines->HasShadingModel(MSM_Subsurface) || EnumHasAnyFlags(EnvironmentDefines->SubstrateMaterialBsdfFeatures, ESubstrateBsdfFeature::SSS))
 		{
 			OutEnvironment.SetDefine(TEXT("MATERIAL_SHADINGMODEL_SUBSURFACE"), TEXT("1"));
@@ -3009,6 +3014,12 @@ void FHLSLMaterialTranslator::GetMaterialEnvironment(EShaderPlatform InPlatform,
 			bMaterialRequestsDualSourceBlending = true;
 		}
 
+		if (EnvironmentDefines->HasShadingModel(MSM_LitReactive))
+		{
+			OutEnvironment.SetDefine(TEXT("MATERIAL_SHADINGMODEL_LIT_REACTIVE"), TEXT("1"));
+		}
+
+
 		if (EnvironmentDefines->bDisableForwardLocalLights)
 		{
 			OutEnvironment.SetDefine(TEXT("DISABLE_FORWARD_LOCAL_LIGHTS"), TEXT("1"));
diff --git a/Engine/Source/Runtime/Engine/Private/Materials/Material.cpp b/Engine/Source/Runtime/Engine/Private/Materials/Material.cpp
index 1857bc7934..175853ea18 100644
--- a/Engine/Source/Runtime/Engine/Private/Materials/Material.cpp
+++ b/Engine/Source/Runtime/Engine/Private/Materials/Material.cpp
@@ -241,7 +241,7 @@ int32 FMaterialResource::CompilePropertyAndSetMaterialProperty(EMaterialProperty
 		case MP_OpacityMask:
 			// Force basic opaque surfaces to skip masked/translucent-only attributes.
 			// Some features can force the material to create a masked variant which unintentionally runs this dormant code
-			if (GetMaterialDomain() != MD_Surface || !IsOpaqueBlendMode(GetBlendMode()) || (GetShadingModels().IsLit() && !GetShadingModels().HasOnlyShadingModel(MSM_DefaultLit)))
+			if (GetMaterialDomain() != MD_Surface || !IsOpaqueBlendMode(GetBlendMode()) || (GetShadingModels().IsLit() && !GetShadingModels().HasOnlyShadingModel(MSM_DefaultLit) && !GetShadingModels().HasOnlyShadingModel(MSM_LitReactive)))
 			{
 				Ret = MaterialInterface->CompileProperty(Compiler, Property);
 			}
@@ -3463,6 +3463,7 @@ static void AddSurfaceSubstrateShadingModelFromMaterialShadingModels(FSubstrateM
 	if (InShadingModels.HasShadingModel(MSM_Eye))				{ OutInfo.AddShadingModel(ESubstrateShadingModel::SSM_Eye); }
 	if (InShadingModels.HasShadingModel(MSM_SingleLayerWater))	{ OutInfo.AddShadingModel(ESubstrateShadingModel::SSM_SingleLayerWater); }
 	if (InShadingModels.HasShadingModel(MSM_ThinTranslucent))	{ OutInfo.AddShadingModel(ESubstrateShadingModel::SSM_ThinTranslucent); }
+	if (InShadingModels.HasShadingModel(MSM_LitReactive))		{ OutInfo.AddShadingModel(ESubstrateShadingModel::SSM_DefaultLit); }
 }
 
 static void AddSurfaceSubstrateShadingModelFromMaterialShadingModel(FSubstrateMaterialInfo& OutInfo, const EMaterialShadingModel& InShadingModel)
@@ -7849,7 +7850,7 @@ static bool IsPropertyActive_Internal(EMaterialProperty InProperty,
 			Active = ShadingModels.IsLit() && (!bIsTranslucentBlendMode || !bIsVolumetricTranslucencyLightingMode);
 			break;
 		case MP_Anisotropy:
-			Active = ShadingModels.HasAnyShadingModel({ MSM_DefaultLit, MSM_ClearCoat }) && (!bIsTranslucentBlendMode || !bIsVolumetricTranslucencyLightingMode);
+			Active = ShadingModels.HasAnyShadingModel({ MSM_DefaultLit, MSM_ClearCoat, MSM_LitReactive }) && (!bIsTranslucentBlendMode || !bIsVolumetricTranslucencyLightingMode);
 			break;
 		case MP_Metallic:
 			// Subsurface models store opacity in place of Metallic in the GBuffer
@@ -7859,13 +7860,13 @@ static bool IsPropertyActive_Internal(EMaterialProperty InProperty,
 			Active = (ShadingModels.IsLit() && (!bIsTranslucentBlendMode || !bIsNonDirectionalTranslucencyLightingMode)) || bUsesDistortion;
 			break;
 		case MP_Tangent:
-			Active = ShadingModels.HasAnyShadingModel({ MSM_DefaultLit, MSM_ClearCoat }) && (!bIsTranslucentBlendMode || !bIsVolumetricTranslucencyLightingMode);
+			Active = ShadingModels.HasAnyShadingModel({ MSM_DefaultLit, MSM_ClearCoat, MSM_LitReactive }) && (!bIsTranslucentBlendMode || !bIsVolumetricTranslucencyLightingMode);
 			break;
 		case MP_SubsurfaceColor:
 			Active = ShadingModels.HasAnyShadingModel({ MSM_Subsurface, MSM_PreintegratedSkin, MSM_TwoSidedFoliage, MSM_Cloth });
 			break;
 		case MP_CustomData0:
-			Active = ShadingModels.HasAnyShadingModel({ MSM_ClearCoat, MSM_Hair, MSM_Cloth, MSM_Eye, MSM_SubsurfaceProfile });
+			Active = ShadingModels.HasAnyShadingModel({ MSM_ClearCoat, MSM_Hair, MSM_Cloth, MSM_Eye, MSM_SubsurfaceProfile, MSM_LitReactive });
 			break;
 		case MP_CustomData1:
 			Active = ShadingModels.HasAnyShadingModel({ MSM_ClearCoat, MSM_Eye });
diff --git a/Engine/Source/Runtime/Engine/Private/Materials/MaterialAttributeDefinitionMap.cpp b/Engine/Source/Runtime/Engine/Private/Materials/MaterialAttributeDefinitionMap.cpp
index aab81805b9..84d73b148f 100644
--- a/Engine/Source/Runtime/Engine/Private/Materials/MaterialAttributeDefinitionMap.cpp
+++ b/Engine/Source/Runtime/Engine/Private/Materials/MaterialAttributeDefinitionMap.cpp
@@ -493,6 +493,7 @@ FText FMaterialAttributeDefinitionMap::GetAttributeOverrideForMaterial(const FGu
 		CustomPinNames.Add({ MSM_Cloth, LOCTEXT("Cloth", "Cloth").ToString() });
 		CustomPinNames.Add({ MSM_Eye, LOCTEXT("IrisMask", "Iris Mask").ToString() });
 		CustomPinNames.Add({ MSM_SubsurfaceProfile, LOCTEXT("Curvature", "Curvature").ToString() });
+		CustomPinNames.Add({ MSM_LitReactive, LOCTEXT("Reactivity", "Reactivity").ToString() });
 		return FText::FromString(GetPinNameFromShadingModelField(Material->GetShadingModels(), CustomPinNames, LOCTEXT("CustomData0", "Custom Data 0").ToString()));
 	case MP_CustomData1:
 		CustomPinNames.Add({ MSM_ClearCoat, LOCTEXT("ClearCoatRoughness", "Clear Coat Roughness").ToString() });
diff --git a/Engine/Source/Runtime/Engine/Private/Materials/MaterialInterface.cpp b/Engine/Source/Runtime/Engine/Private/Materials/MaterialInterface.cpp
index 153f738401..99dbdd0bb1 100644
--- a/Engine/Source/Runtime/Engine/Private/Materials/MaterialInterface.cpp
+++ b/Engine/Source/Runtime/Engine/Private/Materials/MaterialInterface.cpp
@@ -524,7 +524,7 @@ FMaterialRelevance UMaterialInterface::GetRelevance_Internal(const UMaterial* Ma
 
 	// Note that even though XX_GameThread() api is called, this function can be called on non game thread via 
 	// GetRelevance_Concurrent()
-	bool bUsesAnisotropy = MaterialResource->GetShadingModels().HasAnyShadingModel({ MSM_DefaultLit, MSM_ClearCoat }) && 
+	bool bUsesAnisotropy = MaterialResource->GetShadingModels().HasAnyShadingModel({ MSM_DefaultLit, MSM_ClearCoat, MSM_LitReactive }) &&
 		MaterialResource->MaterialUsesAnisotropy_GameThread();
 
 	const EBlendMode BlendMode = (EBlendMode)GetBlendMode();
diff --git a/Engine/Source/Runtime/Engine/Private/Materials/MaterialShader.cpp b/Engine/Source/Runtime/Engine/Private/Materials/MaterialShader.cpp
index 5bd32057e9..7f3a5d3def 100644
--- a/Engine/Source/Runtime/Engine/Private/Materials/MaterialShader.cpp
+++ b/Engine/Source/Runtime/Engine/Private/Materials/MaterialShader.cpp
@@ -137,6 +137,7 @@ FString GetShadingModelString(EMaterialShadingModel ShadingModel)
 		case MSM_Eye:				ShadingModelName = TEXT("MSM_Eye"); break;
 		case MSM_SingleLayerWater:	ShadingModelName = TEXT("MSM_SingleLayerWater"); break;
 		case MSM_ThinTranslucent:	ShadingModelName = TEXT("MSM_ThinTranslucent"); break;
+		case MSM_LitReactive:       ShadingModelName = TEXT("MSM_LitReactive"); break;
 		default: ShadingModelName = TEXT("Unknown"); break;
 	}
 	return ShadingModelName;
@@ -739,7 +740,7 @@ void UpdateMaterialShaderCompilingStats(const FMaterial* Material)
 	{
 		INC_DWORD_STAT_BY(STAT_ShaderCompiling_NumUnlitMaterialShaders, 1);
 	}
-	else if (ShadingModels.HasAnyShadingModel({ MSM_DefaultLit, MSM_Subsurface, MSM_PreintegratedSkin, MSM_ClearCoat, MSM_Cloth, MSM_SubsurfaceProfile, MSM_TwoSidedFoliage, MSM_SingleLayerWater, MSM_ThinTranslucent }))
+	else if (ShadingModels.HasAnyShadingModel({ MSM_DefaultLit, MSM_Subsurface, MSM_PreintegratedSkin, MSM_ClearCoat, MSM_Cloth, MSM_SubsurfaceProfile, MSM_TwoSidedFoliage, MSM_SingleLayerWater, MSM_ThinTranslucent, MSM_LitReactive }))
 	{
 		INC_DWORD_STAT_BY(STAT_ShaderCompiling_NumLitMaterialShaders, 1);
 	}
diff --git a/Engine/Source/Runtime/Engine/Private/ShaderCompiler/ShaderGenerationUtil.cpp b/Engine/Source/Runtime/Engine/Private/ShaderCompiler/ShaderGenerationUtil.cpp
index 05d4f7474d..3c83fa1756 100644
--- a/Engine/Source/Runtime/Engine/Private/ShaderCompiler/ShaderGenerationUtil.cpp
+++ b/Engine/Source/Runtime/Engine/Private/ShaderCompiler/ShaderGenerationUtil.cpp
@@ -130,6 +130,7 @@ void ApplyFetchEnvironmentInternal(FShaderMaterialPropertyDefines& SrcDefines, c
 	FETCH_COMPILE_BOOL(MATERIAL_SHADINGMODEL_EYE);
 	FETCH_COMPILE_BOOL(MATERIAL_SHADINGMODEL_SINGLELAYERWATER);
 	FETCH_COMPILE_BOOL(MATERIAL_SHADINGMODEL_THIN_TRANSLUCENT);
+	FETCH_COMPILE_BOOL(MATERIAL_SHADINGMODEL_LIT_REACTIVE);
 
 	FETCH_COMPILE_BOOL(SINGLE_LAYER_WATER_SEPARATED_MAIN_LIGHT);
 
@@ -1637,6 +1638,10 @@ static void SetSlotsForShadingModelType(bool Slots[], EMaterialShadingModel Shad
 	case MSM_DefaultLit:
 		SetSharedGBufferSlots(Slots);
 		break;
+	case MSM_LitReactive:
+		SetSharedGBufferSlots(Slots);
+		Slots[GBS_CustomData] = true;
+		break;
 	case MSM_Subsurface:
 		SetSharedGBufferSlots(Slots);
 		if (bMergeCustom)
@@ -1830,6 +1835,12 @@ static void DetermineUsedMaterialSlots(
 		SetStandardGBufferSlots(Slots, bWriteEmissive, bHasTangent, bHasVelocity, bWritesVelocity, bHasStaticLighting, bIsSubstrateMaterial, bIsSubstrateNewGBuffer);
 	}
 
+	if (Mat.MATERIAL_SHADINGMODEL_LIT_REACTIVE)
+	{
+		SetStandardGBufferSlots(Slots, bWriteEmissive, bHasTangent, bHasVelocity, bWritesVelocity, bHasStaticLighting, bIsSubstrateMaterial, bIsSubstrateNewGBuffer);
+		Slots[GBS_CustomData] = GetGBufferSlotUsage(bUseCustomData);
+	}
+
 	if (Mat.MATERIAL_SHADINGMODEL_SUBSURFACE)
 	{
 		SetStandardGBufferSlots(Slots, bWriteEmissive, bHasTangent, bHasVelocity, bWritesVelocity, bHasStaticLighting, bIsSubstrateMaterial, bIsSubstrateNewGBuffer);
diff --git a/Engine/Source/Runtime/RenderCore/Public/ShaderMaterial.h b/Engine/Source/Runtime/RenderCore/Public/ShaderMaterial.h
index ea7933e08f..6a296842c3 100644
--- a/Engine/Source/Runtime/RenderCore/Public/ShaderMaterial.h
+++ b/Engine/Source/Runtime/RenderCore/Public/ShaderMaterial.h
@@ -119,6 +119,7 @@ struct FShaderMaterialPropertyDefines
 	uint8 MATERIAL_SHADINGMODEL_SINGLELAYERWATER : 1;
 	uint8 SINGLE_LAYER_WATER_SEPARATED_MAIN_LIGHT : 1;
 	uint8 MATERIAL_SHADINGMODEL_THIN_TRANSLUCENT : 1;
+	uint8 MATERIAL_SHADINGMODEL_LIT_REACTIVE : 1;
 
 	uint8 TRANSLUCENCY_LIGHTING_VOLUMETRIC_NONDIRECTIONAL : 1;
 	uint8 TRANSLUCENCY_LIGHTING_VOLUMETRIC_DIRECTIONAL : 1;
diff --git a/Engine/Source/Runtime/Renderer/Private/AnisotropyRendering.cpp b/Engine/Source/Runtime/Renderer/Private/AnisotropyRendering.cpp
index 4995241a53..88b31cd453 100644
--- a/Engine/Source/Runtime/Renderer/Private/AnisotropyRendering.cpp
+++ b/Engine/Source/Runtime/Renderer/Private/AnisotropyRendering.cpp
@@ -39,7 +39,8 @@ static bool IsAnisotropyPassCompatible(const EShaderPlatform Platform, FMaterial
 		FDataDrivenShaderPlatformInfo::GetSupportsAnisotropicMaterials(Platform) &&
 		MaterialParameters.bHasAnisotropyConnected &&
 		!IsTranslucentBlendMode(MaterialParameters) &&
-		MaterialParameters.ShadingModels.HasAnyShadingModel({ MSM_DefaultLit, MSM_ClearCoat, MSM_Strata }) &&
+		MaterialParameters.ShadingModels.HasAnyShadingModel({ MSM_DefaultLit, MSM_ClearCoat, MSM_LitReactive });
+		MaterialParameters.ShadingModels.HasAnyShadingModel({ MSM_DefaultLit, MSM_ClearCoat, MSM_Strata, MSM_LitReactive }) &&
 		(!bSubstrateEnabled || (bSubstrateEnabled && Substrate::IsSubstrateBlendableGBufferEnabled(Platform))); // Substrate renders anisotropy surface natively, without extra pass. Unless blendable gbuffer is used.
 }
 
@@ -145,7 +146,7 @@ bool GetAnisotropyPassShaders(
 static bool ShouldDraw(const FMaterial& Material, bool bMaterialUsesAnisotropy)
 {
 	const bool bIsNotTranslucent = IsOpaqueOrMaskedBlendMode(Material);
-	return (bMaterialUsesAnisotropy && bIsNotTranslucent && Material.GetShadingModels().HasAnyShadingModel({ MSM_DefaultLit, MSM_ClearCoat }));
+	return (bMaterialUsesAnisotropy && bIsNotTranslucent && Material.GetShadingModels().HasAnyShadingModel({ MSM_DefaultLit, MSM_ClearCoat, MSM_LitReactive }));
 }
 
 void FAnisotropyMeshProcessor::AddMeshBatch(
diff --git a/Engine/Source/Runtime/Renderer/Private/PrimitiveSceneInfo.cpp b/Engine/Source/Runtime/Renderer/Private/PrimitiveSceneInfo.cpp
index ad933893e9..24254e2a31 100644
--- a/Engine/Source/Runtime/Renderer/Private/PrimitiveSceneInfo.cpp
+++ b/Engine/Source/Runtime/Renderer/Private/PrimitiveSceneInfo.cpp
@@ -135,7 +135,7 @@ public:
 			const FMaterial& Material = Mesh.MaterialRenderProxy->GetIncompleteMaterialWithFallback(FeatureLevel);
 			bool bUseSkyMaterial = Material.IsSky();
 			bool bUseSingleLayerWaterMaterial = Material.GetShadingModels().HasShadingModel(MSM_SingleLayerWater);
-			bool bUseAnisotropy = Material.GetShadingModels().HasAnyShadingModel({MSM_DefaultLit, MSM_ClearCoat}) && Material.MaterialUsesAnisotropy_RenderThread();
+			bool bUseAnisotropy = Material.GetShadingModels().HasAnyShadingModel({MSM_DefaultLit, MSM_ClearCoat, MSM_LitReactive}) && Material.MaterialUsesAnisotropy_RenderThread();
 			bool bSupportsNaniteRendering = SupportsNaniteRendering(StaticMesh->VertexFactory, PrimitiveSceneProxy, Mesh.MaterialRenderProxy, FeatureLevel);
 			bool bSupportsGPUScene = StaticMesh->VertexFactory->SupportsGPUScene(FeatureLevel);
 			bool bUseForWaterInfoTextureDepth = Mesh.bUseForWaterInfoTextureDepth;
